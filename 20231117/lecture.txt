배열 객체 Array

일반적인 변수는 값을 1개 저장
배열 객체는 여러 개의 값을 저장할 수 있다

인덱스 번호 = 배열 내에서 값의 위치를 
나타내는 수 (0부터 시작)

배열 객체를 생성할 때에는
let 변수 = new Array(값들);
[]를 이용해서도 생성할 수 있음
let 변수 = [값들];

반복문에서 배열을 확인하는 방법
- 인덱스 번호를 이용하는 방법
- 객체를 직접 확인하는 방법
  -> in 연사자를 사용

배열.length: 배열의 크기

배열 함수들
배열.join(연결문자)
-> 배열에 들어있는 값들을 연결문자를
이용해서 하나의 문자열로 연결한다

배열.reverse()
-> 배열을 뒤집는다

배열.sort()
-> 배열에 있는 데이터를 오름차순으로 정렬
유니코드 순으로 오름차순
'0' -> 48
'A' -> 65
'a' -> 97
'가' -> 44032

배열.slice(인덱스1, 인덱스2)
배열에서 인덱스1 이상부터 인덱스2
""미만""까지의 값을 가져온다 (-1)

배열.concat(다른배열)
concatenate의 줄임말
다른 배열을 배열에 추가

배열.pop()
-> 배열의 마지막 값을 삭제
배열.push(값)
-> 배열의 마지막에 값을 추가

배열.shift()
-> 배열의 첫 번째 값을 삭제
배열.unshift(값)
-> 배열의 첫 번째 값을 추가

배열.indexOf(값)
-> 해당 값의 인덱스번호가 나옴

다른함수와 엮여서 사용되는 함수
배열.every(함수)
배열.some(함수)

->안에 들어있는 함수는 ture 또는 false를 
반환해야 한다

-> every : 배열에 있는 "모든" 값들이 함수에서
true를 리턴받으면 true, 아니면 false

-> some : 배열에 있는 "아무" 값들이 함수에서
true를 리턴받으면 true, 아니면 false

배열.forEach(함수)
-> 배열에 있는 각각의 변수를 함수에
집어넣는다.

배열.map(함수)
배열.filter(함수)

-> map : 값을 함수에 넣어서 바꾸는 것
return 값이 아무것이여도 됨
-> filter : 값을 함수에 넣은 결과가 true인
것만 남겨두는 것
return 값이 true/false로 나와야 함

배열.toString()
배열.valueOf()
배열을 문자열로 바꾸어서 출력한다

[basket.hmtl]
오늘 구매할 상품 종류의 수를 입력하세요
예) 4 -> 총 4번 "아이템을 입력하세요" prompt를 반복
입력 받은 값들을 basket 이름의 배열에 저장

딸기, 수박, 참외, 메론
딸기, 메론, 수박, 참외 (정렬 해서 출력)

[rsp2.html]
컴퓨터1, 컴퓨터2
컴퓨터1 랜덤을 이용해서 총 30번한 값
컴퓨터2 랜덤을 이용해서 총 30번한 값

1: 가위 , 2: 바위, 3: 보
컴퓨터1; 1 2 3 1 2 3 1 2 3
컴퓨터2; 1 2 3 1 2 3 1 2 3

라운드별로 비교를 해서 나온 값을 출력
컴퓨터1의 승, 무승부, 패, 승률(반올림 소수점 2자리까지)까지

소수점 반올림 -> toFixed 함수

문자열 객체 (String)

let a = 'Hello';
let a = 'Hello';
let b = new String("Hello");

인덱스
[] 아니면 문자열,charAt(인덱스번호)
문자열의 특정 인덱스 번호에 있는 문자

문자열.charCodeAt(인덱스번호)
-> 해당 인덱스번호 위치에 있는 문자의 Unicode 번호

문자열.indexOf(찾을문자열)
-> 문자열에서 찾을 문자열이 있는 가장 첫 인덱스 번호

문자열.lastIndexOf(찾을문자열)
-> 문자열에서 찾을 문자열이 있는 가장 마지막 인덱스 번호
인덱스 번호 (없으면 -1)

문자열.match(찾은문자열)
-> 문자열에서 찾을 문자열과 일치하는 문자열을
찾아서 제일 먼저 찾은 문자 (없으면 null)

문자열.replace(찾을문자열, 바꿀문자열)
-> 문자열에서 찾을 문자열을 찾아서 통째로 바꿀
문자열로 교체

문자열.slice(인덱스1, 인덱스2)
문자열.substring(인덱스1, 인덱스2)
-> 인덱스 1이상, 인덱스 2 ""미만"" 의 문자열의
일부를 가져온다

문자열.substr(인덱스, 길이)
-> 해당 인덱스부터 길이만큼 문자열의 일부를 가져온다

문자열.split(구분자)
-> 구분자로 문자열을 나누어서 배열에 저장

문자열.toLowerCase()
문자열.toUpperCase()
-> 전부 소문자로, 전부 대문자로 변경

문자열.concat(다른문자열)
-> 문자열에 다른 문자열을 추가한다

문자열.trim()
-> 양 옆의 공백을 제거

문자열.length **뒤에 괄호 안붙음**
-> 문자열 길이

유니코드 숫자 -> 문자
String.fromCharCode(유니코드 숫자)

한글 '가' ~ '힣' 까지가 조합형 한글 유니코드
44032 ~ 55203
초성: ㄱ, ㄲ, ㄴ, ㄷ, ㄸ, ㄹ, ㅁ, ㅂ, ㅃ, ㅅ, ㅇ, ㅈ, ㅉ, 
ㅊ, ㅋ, ㅌ, ㅍ, ㅎ
중성: ㅏ, ㅐ ㅑ, ㅒ, ㅓ, ㅔ, ㅕ, ㅖ, ㅗ, ㅘ, ㅛ, ㅜ, 
ㅝ, ㅞ, ㅟ, ㅠ, ㅡ, ㅢ, ㅣ (0~20)
종성: X, ㄱ, ㄲ, ㄳ, ㄴ, ㄵ, ㄶ, ㄷ, ㄹ, ㄺ, ㄻ, ㄼ, ㄽ, ㄾ,
ㄿ, ㅀ, ㅁ, ㅂ, ㅄ, ㅅ, ㅆ, ㅇ, ㅈ, ㅊ, ㅋ, ㅌ, ㅍ, ㅎ (0~27)

44032 + 초성번호 * 588 + 중성번호 * 28 + 종성번호
문: 44032 + 6 * 588 + 13 * 28 + 4

[hangueol.html]
한글의 초성, 중성, 종성을 prompt로 입력받기
(종성이 없으면 "없음" 으로 받기)
각각을 조합해서 하나의 문자를 출력

ㄱ+ㅣ+ㅁ=김

[email.html]
이메일이 유효한지 체크하는 사이트
prompt로 이메일 주소를 입력
입력 받은 겂에 대해서 유효한 이메일인지 확인
조건 1. @이 반드시 있어야 한다 
조건 2. @앞에 적어도 3자리 이상의 문자가 있어야 한다
조건 3. 도메인이 .co.kr, .com, .net, .org, .or.kr 로
끝나야 한다
조건 4. 도메인을 제외한 @ 뒤쪽 문자의 개수가 3개 이상이어야
하는데, 반드시 영어 대소문자, 숫자, 한글로만 이루어져야 함

위 조건 4개를 모두 충족하면 
~~~@~~~.~~~는 유효한 이메일입니다.

만족하지 못할 경우
~~~@~~~.~~~는 유효하지 않는 이메일입니다.
조건을 만족하지 못한 첫번째 조건에 대한 설명을 출력